# hello world

스크립트 사용법, 외부 스크립트 사용법

> ## code
>
> index.html
>
> ```
> <!DOCTYPE html>
> <html>
>  <body>
>    <script src="index.js"></script>
>  </body>
> </html>
> ```
>
> index.js
>
> `alert("자바스크립트!");`

#

# 코드 구조

세미콜론은 웬만하면 쓰도록 하자

한줄주석 : //

여러줄주석 : /\*\*/

#

# 엄격 모드

`"use stric"`

이 코드는 모던한 방식으로 실행됩니다

주의 : 최상단에 위치시켜야만 반영

> 결론은 이렇습니다. 코드를 클래스와 모듈을 사용해 구성한다면 "use strict"를 생략해도 됩니다. 그런데 아직은 이 둘을 배우지 않았으니 "use strict"를 귀한 손님처럼 모시도록 하겠습니다.

> 다음 챕터부터는 자바스크립트 언어가 제공하는 기능들을 하나씩 학습하면서 이 기능들이 엄격 모드와 비 엄격 모드에서 어떤 차이점을 보이는지 알아보겠습니다. 희소식을 알려드리자면 두 모드에서 차이를 보이는 기능이 많지 않다는 점과 엄격 모드를 사용하면 개발자의 삶의 질이 조금 더 높아진다는 점입니다.

> 그리고 특별한 언급이 없는 한 이 튜토리얼에 등장하는 모든 예시엔 엄격 모드를 적용할 예정입니다.

#

# 변수와 상수

`let`, `const` 사용법

대문자 상수 : 관습

`var` : 오래된 변수 선언 키워드

## 변수명 짓는법

- userName 이나 shoppingCart처럼 사람이 읽을 수 있는 이름을 사용하세요.
  무엇을 하고 있는지 명확히 알고 있지 않을 경우 외에는 줄임말이나 a, b, c와 같은 짧은 이름은 피하세요.
- 최대한 서술적이고 간결하게 명명해 주세요. data와 value는 나쁜 이름의 예시입니다. 이런 이름은 아무것도 설명해주지 않습니다. 코드 문맥상 변수가 가리키는 데이터나 값이 아주 명확할 때에만 이런 이름을 사용합시다.
- 자신만의 규칙이나 소속된 팀의 규칙을 따르세요. 만약 사이트 방문객을 'user’라고 부르기로 했다면, 이와 관련된 변수를 currentVisitor나 newManInTown이 아닌 currentUser나 newUser라는 이름으로 지어야 합니다.

#

# 자료형

## 숫자형

숫자형에는 일반적인 숫자 외에 `Infinity`, `-Infinity`, `NaN` 같은 특수 문자 값이 포함됩니다

- `Infinity`는 무한대를 나타냅니다
- `NaN`은 계산중 에러가 발생했다는 것을 나타냅니다.

## BigInt

`BigInt`형은 길이에 상관없이 정수를 나타낼 수 있습니다.

정수 끝에 `n`을 붙이면 만들 수 있습니다.

```
const bigInt = 1234567890123456789012345678901234567890n;
```

## 문자형

따옴표는 세 종류가 있습니다.

1. 큰따옴표 : `"str"`
2. 작은따옴표 : `'str'`
3. 백틱 : <code>`str`</code>

> 역 따옴표로 변수나 표현식을 감싼 후 \${…}안에 넣어주면, 아래와 같이 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있습니다.
>
> 큰따옴표나 작은따옴표를 사용하면 중간에 표현식을 넣을 수 없다는 점에 주의하시기 바랍니다. 이 방법은 역 따옴표를 써야만 가능합니다.

## 불린형

`true`와 `false` 두 가지 값만 있는 자료형입니다.

## null

자바스크립트의 `null`은 자바스크립트 이외 언어의 `null`과 성격이 다릅니다. 다른 언어에선 `null`을 '존재하지 않는 객체에 대한 참조’나 '널 포인터(null pointer)'를 나타낼 때 사용합니다.

하지만 자바스크립트에선 `null`을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용합니다.

`let age = null;`은 나이(age)를 알 수 없거나 그 값이 비어있음을 보여줍니다.

## undefined

`undefined`는 값이 할당되지 않은 상태를 나타낼 때 사용합니다.

변수 선언 후 값을 할당하지 않으면 자동으로 `undefined`가 할당됩니다.

```
let age;

alert(age); // 'undefined'가 출력됩니다
```

> 하지만 이렇게 `undefined`를 직접 할당하는 걸 권장하진 않습니다. 변수가 ‘비어있거나’ ‘알 수 없는’ 상태라는 걸 나타내려면 `null`을 사용하세요. `undefined`는 값이 할당되지 않은 변수의 초기값을 위해 예약어로 남겨둡시다.

## 객체와 심볼

`객체(object)` 형은 특수한 자료형입니다.

객체를 제외한 다른 자료형 : 원시 자료형 <-> 객체 : 더욱 복잡한 개체를 표현가능

`심볼(symbol)` 형은 객체의 식별자를 만들때 사용됩니다.

## typeof 연산자

변수의 자료형을 알아내고자 할때 사용합니다.

두가지 형태의 문법을 지원합니다.

1. 연산자 : `typeof x`
2. 함수 : `typeof (x)`

`typeof x`호출시 인수의 자료형을 나타내는 문자열을 반환합니다.

```
typeof "string" // string
```

#

# alert, prompt, confirm을 이용한 상호작용

## alert

```
alert("Hello");
```

메시지를 보여주는 창이 떠있게 됩니다.

## prompt

`prompt` 함수는 두 개의 인수를 받습니다.

```
res = prompt(title, [default]);
```

텍스트 메시지와 입력 필드, 확인과 취소 버튼이 있는 창을 띄워줍니다.

`title` : 사용자에게 보여줄 문자열

`default` : 입력 필드의 초깃값(선택값)

> 사용자는 프롬프트 대화상자의 입력 필드에 원하는 값을 입력하고 확인을 누를 수 있습니다. 값을 입력하길 원하지 않는 경우는 취소(Cancel) 버튼을 누르거나 Esc를 눌러 대화상자를 빠져나가면 됩니다.
>
> `prompt` 함수는 사용자가 입력 필드에 기재한 문자열을 반환합니다. 사용자가 입력을 취소한 경우는 null이 반환됩니다.

## confirm

```
res = confirm(question);
```

`confirm` 함수는 매개변수로 받은 `question`과 확인 및 취소 버튼이 있는 모달 창을 보여줍니다.

사용자가 확인버튼를 누르면 `true`, 그 외의 경우는 `false`를 반환합니다.

#

# 형 변환

## 문자형으로 변환

`alert` 메서드는 매개변수로 문자형을 받아서 `alert(value)`에서 value는 문자형이어야 합니다. 다른 형의 값이면 자동으로 변환됩니다. `false`는 `"false"`로, `null`은 `"null"`로 변환됩니다.

`String(value)`로 형변환 가능

## 숫자형으로 변환

수학과 관련된 함수와 표현식에서 자동으로 일어납니ㅏㄷ.

```
alert( "6" / "2" ); // 문자열이 자동 변환된 후 연산
```

`Number(value)`로 형변환 가능

숫자 이외의 글자가 들어있는 문자열을 숫자형으로 변환하려고 하면 결과값은 `NaN`이 됩니다.

> 전달받은 값 : 형 변환 후
>
> `undefined` : `NaN`
>
> `null` : 0
>
> `true` and `false` : 1 과 0
>
> `string` : 문자열의 처음과 끝 공백이 제거됩니다. 공백 제거 후 남아있는 문자열이 없다면 0, 그렇지 않다면 문자열에서 숫자를 읽습니다. 변환에 실패하면 NaN이 됩니다.

## 불린형으로 변환

`Boolean(value)`로 형변환 가능

- 숫자 0, 빈 문자열, null, undefined, NaN과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 false가 됩니다.
- 그 외의 값은 true로 변환됩니다.

- PHP 등의 일부 언어에선 문자열 "0"을 false로 취급합니다. 그러나 자바스크립트에선 비어 있지 않은 문자열은 언제나 true입니다.

#

# 기본 연산자와 수학

## 용어 : '단항', '이항', '피연산자'

_피연산자_ : 연산자가 연산을 수행하는 대상. ex) `5 * 2` : 5, 2가 피연산자

_단항 연산자_ : 피연산자를 하나만 받는 연산자

_이항 연산자_ : 두 개의 피연산자를 받는 연산자

## 수학

> 덧셈 연산자 `+`,
>
> 뺄셈 연산자 `-`,
>
> 곱셈 연산자 `*`,
>
> 나눗셈 연산자 `/`,
>
> 나머지 연산자 `%`,
>
> 거듭제곱 연산자 `**`

## 이항 연산자 '+'와 문자열 연결

`+`의 피연산자로 문자열이 전달되면 문자열을 병합합니다.

```
let s = "my" + "string";
alert(s); // mystring
```

## 단항 연산자 '+'와 숫자형으로의 변환

피연산자가 숫자가 아닌 경우 단항 덧셈 연산자를 붙이면 숫자형으로의 변환이 일어납니다.

```
let apple = "2";
let oranges = "3";

alert( +apple + +oranges );
//Number()를 사용해도 같은 동작을 하는 코드를 작성할 수 있어요
```

## 할당 연산자

`=`도 연산자입니다. `=` 역시 값을 반환합니다.

```
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

## 할당 연산자 체이닝

아래와 같이 여러 개를 연결할 수도 있습니다.

```
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

## 복합 할당 연산자

`+=`과 `*=`

## 증감 연산자

- 증가 연산자 : `++`
- 감소 연산자 : `--`

#

# 비교 연산자

- 큼, 작음 : `a > b`, `a < b`
- 크거나.작거나 같음 : `a >= b`, `a <= b`
- 같음 : `a == b`
- 같지 않음 : `a != b`

## 문자열 비교

유니코드 순으로 문자열을 비교합니다. 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.

> 문자열 비교 시 적용되는 알고리즘은 다음과 같습니다.
>
> 두 문자열의 첫 글자를 비교합니다.
>
> 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료합니다.
>
> 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교합니다.
>
> 글자 간 비교가 끝날 때까지 이 과정을 반복합니다.
>
> 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 냅니다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 냅니다.

## 다른 형의 비교

비교하려는 값의 자료형이 다르면 이 값들을 숫자형으로 바꾼 후 비교가 이뤄집니다.

불린의 경우 `true`는 `1` `false`는 `0`으로 변환된 후 비교됩니다.

## 일치 연산자

동등연산자 `==` : 형 구분 x
일치연산자 `===` : 형 구분 o

#

# if와 '?'를 사용한 조건 처리

## if문

`if(...)`은 괄호 안이 `true`이면 코드 블록이 실행됩니다.

`else`, `else if` : 조건 처리

## 조건부 연산자 '?'

피연산자가 세 개이기 때문에 조건부 연산자를 '삼항 연산자'라고 부르기도 합니다.

### 문법

```
let result = condition ? val1 : val2;
```

평가 대상인 `conditio`이 true라면 `val1`이, 그렇지 않으면 `val2`가 반환됩니다.

#

# 논리 연산자

`||`(OR) , `&&`(AND) , `!`(NOT) 세 종류의 논리 연산자가 있습니다.

## || (OR)

피연산자가 모두 `false`인 경우를 제외하고는 연산 결과는 항상 `true`입니다.

## 첫 번째 truthy를 찾는 OR 연산자

자바스크립트에서만 제공하는 OR의 추가 기능에 대해 알아보겠습니다.

OR 연산자와 피연산자가 여러 개인 경우

```
res = val1 || val2 || val3;
```

OR 연산자가 연산을 하는 순서

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가합니다.
- 각 피연산자를 불린형으로 변환합니다. 변환 후 그 값이 true이면 연산을 멈추고 해당 피연산자의 변환 전 원래 값을 반환합니다.
- 피연산자 모두를 평가한 경우(모든 피연산자가 false로 평가되는 경우)엔 마지막 피연산자를 반환합니다.

이런 OR의 추가 기능을 이용하면 여러 용도로 활용할 수 있습니다.

1. 변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기

   firstName, lastName, nickName이란 변수가 있는데 이 값들은 모두 옵션 값이라고 해봅시다.

   OR ||을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있습니다. 변수 모두에 값이 없는 경우엔 익명를 보여줍시다.

   ```
   let firstName = "";
   let lastName = "";
   let nickName = "바이올렛"

   alert( firstName || lastName || nickName || "익명"); // 바이올렛
   ```

   모든 변수가 falsy이면 "익명"이 출력되었을 겁니다.

2. 단락 평가

   OR 연산자가 제공하는 또 다른 기능은 '단락 평가(short circuit evaluation)'입니다.

   위에서 설명해 드린 바와 같이 OR은 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, truthy를 만나면 나머지 값들은 건드리지 않은 채 평가를 멈춥니다. 이런 프로세스를 '단락 평가’라고 합니다.

   단락 평가의 동작 방식은 두 번째 피연산자가 변수 할당과 같은 부수적인 효과(side effect)를 가지는 표현식 일 때 명확히 볼 수 있습니다.

   아래 예시를 실행하면 두 번째 메시지만 출력됩니다.

   ```
   true || alert("not printed");
   false || alert("printed");
   ```

   첫 번째 줄의 || 연산자는 true를 만나자마자 평가를 멈추기 때문에 alert가 실행되지 않습니다.

   단락 평가는 연산자 왼쪽 조건이 falsy일 때만 명령어를 실행하고자 할 때 자주 쓰입니다.

## && (AND)

AND연산자는 두 연산자가 모두 참일 때 `true`를 반환합니다. 그 외에는 `false`를 반환합니다.

## 첫 번째 falsy를 찾는 AND 연산자 '&&'

AND 연산자는 아래와 같이 동작합니다.

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가합니다.
- 각 피연산자는 불린형으로 변환됩니다. 변환 후 값이 `false`이면 평가를 멈추고 해당 피연산자의 변환 전 원래 값을 반환합니다.
- 피연산자 모두가 평가되는 경우(모든 피연산자가 `true`로 평가되는 경우)엔 마지막 피연산자가 반환됩니다.

=> AND 연산자는 첫 번째 falsy를 반환합니다. 피연산자에 falsy가 없다면 마지막 값을 반환합니다.

## ! (NOT)

NOT 연산자는 인수를 하나만 받고, 다음 순서대로 연산을 수행합니다.

- 피연산자를 불린형(true / false)으로 변환합니다.
- 앞에서 변환된 값의 역을 반환합니다.

```
result = !value;
```

NOT을 두 개 연달아 사용(`!!`) 하면 값을 불린형으로 변환할 수 있습니다.

```
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

`Boolean`을 사용하면 `!!`를 사용한 것과 같은 결과를 도출할 수 있습니다.

```
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

#

# null 병합 연산자 '??'

null 병합 연산자 `??`를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 확정되어 있는 변수를 찾을 수 있습니다.

`a ?? b`의 결과는 다음과 같습ㄴ이다.

- `a`가 `null`도 아니고 `undefined`도 아니면 `a`
- 그 외의 경우는 `b`

> 또 다른 예시를 살펴봅시다. firstName, lastName, nickName이란 변수에 사용자 이름이나 별명을 저장하는데, 사용자가 아무런 정보도 입력하지 않는 케이스도 허용한다고 해보겠습니다.
>
> 화면엔 세 변수 중, 값이 정해진 변수의 값을 출력하는데, 세 변수 모두 값이 정해지지 않았다면 "Anonymous"가 출력되도록 해보죠.
>
> 이럴 때 null 병합 연산자 ??를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있습니다.
>
> ```
> let firstName = null;
> let lastName = null;
> let nickName = "Supercoder";
>
> // null이나 undefined가 아닌 첫 번째 피연산자
> alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
> ```

## '??'와 '||'의 차이

- `||`는 첫 번째 truthy 값을 반환합니다
- `??`는 첫 번째 정의된 값을 반환합니다

예시

```
height = height ?? 100;
```

`height`에 값이 정의되지 않았다면 `height`엔 `100`이 할당됩니다.

`??`와 `||`를 비교해봅시다.

```
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```

`||`은 `0`을 falsy한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리합니다.

`??`은 `null`이나 `undefined`일 경우에만 falsy한 값으로 취급합니다.

## 연산자 우선순위

`??`의 연산자 우선순위는 5로 꽤 낮습니다. 복잡한 표현식 안에서 `??`를 사용해 값을 선택할 때는 괄호를 추가하는게 좋습니다.

```
let height = null;
let width = null;

// 괄호를 추가!
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```

`??`엔 자바스크립트 언어에서 규정한 또 다른 제약사항이 있습니다.

안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못합니다.

아래 예시를 실행하면 문법 에러가 발생합니다.

```
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```

#

# while, for

## while 반복문

`while`의 문법은 다음과 같습니다.

```
while (condition){
   //code
}
```

`condition`이 truthy이면 반복문의 코드가 실행됩니다.

## do...while 반복문

`do...while`문법을 사용하면 `condition`을 반복문 본문 아래로 옮길수 있습니다.

```
do {
   //code
} while(condition);
```

## for 반복문

`for`의 문법은 다음과 같습니다.

```
for (begin; condition; step){
   //code
}
```

## 구성 요소 생략하기

`begin`, `step`을 생략하는 것이 가능합니다. `condition`도 생략할 수 있지만, 무한 반복문이 실행됩니다.

## 반복문 빠져나오기

`break`를 사용하면 언제든 원하는 때에 반복문을 빠져나올 수 있습니다.

## 다음 반복으로 넘어가기

`continue`지시자는 `break`의 가벼운 버전입니다. 전체 반복문을 멈추지 않고, 현재 실행중인 이터레이션을 멈추고 반복문이 다음 이터레이션을 강제로 실행시키도록 합니다.

## break/continue와 레이블

_레이블_(label) 은 반복문 앞에 콜론과 함께 쓰이는 식별자입니다.

```
lableName: for (...){
   ...
}
```

반복문 안에서 `break <lableName>`문을 사용하면 레이블에 해당하는 반복문을 빠져나올 수 있습니다.

```
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`(${i},${j})의 값`, '');

    // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나옵니다.
    if (!input) break outer; // (*)

    // 입력받은 값을 가지고 무언가를 함
  }
}
alert('완료!');
```

#

# switch문

복수의 `if` 조건문은 `switch`문으로 바꿀 수 있습니다.

```
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

## 여러 개의 case문 묶기

코드가 같은 `case`문은 한데 묶을 수 있습니다.

```
let a = 3;

switch (a) {
  case 4:
    alert('계산이 맞습니다!');
    break;

  case 3: // (*) 두 case문을 묶음
  case 5:
    alert('계산이 틀립니다!');
    alert("수학 수업을 다시 들어보는걸 권유 드립니다.");
    break;

  default:
    alert('계산 결과가 이상하네요.');
}
```

`case 3`과 `case 5`는 동일한 메시지를 보여줍니다.

#

# 함수 선언

```
function showMessage() {
  alert( '안녕하세요!' );
}

showMessage();
```

## 지역 변수

함수 내에서 선언한 변수인 지역 변수는 함수 안에서만 접근할 수 있습니다.

## 외부 변수

함수 내부에서 함수 외부의 변수인 외부 변수에 접근할 수 있습니다. 접근하는 것 뿐만 아니라 수정도 할 수 있습니다.

## 매개변수

매개변수(parameter)를 이용하면 임의의 데이터를 함수 안에 전달할 수 있습니다. 매개변수는 인수(argument)라고 불리기도 합니다.

## 기본값

매개변수에 값을 전달하지 않으면 그 값은 `undefined`가 됩니다.

매개변수에 값을 전달하지 않아도 그 값이 undefined가 되지 않게 하려면 '기본값(default value)'을 설정해주면 됩니다. 매개변수 오른쪽에 =을 붙이고 undefined 대신 설정하고자 하는 기본값을 써주면 되죠.

```
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

## 반환값

함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있습니다. 이때 이 특정 값을 반환 값(return value)이라고 부릅니다.

## 함수 이름짓기

함수는 어떤 동작을 수행하기 위한 코드를 모아놓은 것입니다. 따라서 함수의 이름은 대개 동사입니다. 함수 이름은 가능한 한 간결하고 명확해야 합니다. 함수가 어떤 동작을 하는지 설명할 수 있어야 하죠. 코드를 읽는 사람은 함수 이름만 보고도 함수가 어떤 기능을 하는지 힌트를 얻을 수 있어야 합니다.

함수가 어떤 동작을 하는지 축약해서 설명해주는 동사를 접두어로 붙여 함수 이름을 만드는 게 관습입니다. 다만, 팀 내에서 그 뜻이 반드시 합의된 접두어만 사용해야 합니다.

> "show"로 시작하는 함수는 대개 무언가를 보여주는 함수입니다.
>
> 이 외에 아래와 같은 접두어를 사용할 수 있습니다.
>
> - "get…" – 값을 반환함
> - "calc…" – 무언가를 계산함
> - "create…" – 무언가를 생성함
> - "check…" – 무언가를 확인하고 불린값을 반환함

위 접두어를 사용하면 아래와 같은 함수를 만들 수 있습니다.

```
showMessage(..)     // 메시지를 보여줌
getAge(..)          // 나이를 나타내는 값을 얻고 그 값을 반환함
calcSum(..)         // 합계를 계산하고 그 결과를 반환함
createForm(..)      // form을 생성하고 만들어진 form을 반환함
checkPermission(..) // 승인 여부를 확인하고 true나 false를 반환함
```

## 함수 == 주석

함수는 간결하고, 한 가지 기능만 수행할 수 있게 만들어야 합니다. 함수가 길어지면 함수를 잘게 쪼갤 때가 되었다는 신호로 받아들이셔야 합니다. 함수를 쪼개는 건 쉬운 작업은 아닙니다. 하지만 함수를 분리해 작성하면 많은 장점이 있기 때문에 함수가 길어질 경우엔 함수를 분리해 작성할 것을 권유합니다.

함수를 간결하게 만들면 테스트와 디버깅이 쉬워집니다. 그리고 함수 그 자체로 주석의 역할까지 합니다!

#

# 함수 표현식

함수 선언 방식 외에 함수 표현식(Function Expression) 을 사용해서 함수를 만들 수 있습니다.

함수 표현식으로 함수를 생성해보겠습니다.

```
let sayHi = function() {
  alert( "Hello" );
};
```

## 콜백 함수

함수를 값처럼 전달하는 예시, 함수 표현식에 관한 예시를 좀 더 살펴보겠습니다.

매개변수가 3개 있는 함수, ask(question, yes, no)를 작성해보겠습니다. 각 매개변수에 대한 설명은 아래와 같습니다.

`question`
질문
`yes`
"Yes"라고 답한 경우 실행되는 함수
`no`
"No"라고 답한 경우 실행되는 함수
함수는 반드시 question(질문)을 해야 하고, 사용자의 답변에 따라 `yes()` 나 `no()`를 호출합니다.

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);
```

아래와 같이 함수 표현식을 사용하면 코드 길이가 짧아집니다.

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);
```

ask(...) 안에 함수가 선언된 게 보이시나요? 이렇게 이름 없이 선언한 함수는 익명 함수(anonymous function) 라고 부릅니다. 익명 함수는 (변수에 할당된 게 아니기 때문에) `ask` 바깥에선 접근할 수 없습니다. 위 예시는 의도를 가지고 이렇게 구현하였기 때문에 바깥에서 접근할 수 없어도 문제가 없습니다.

## 함수 표현식 vs 함수 선언문

- 함수 표현식: 함수는 표현식이나 구문 구성(syntax construct) 내부에 생성됩니다. 아래 예시에선 함수가 할당 연산자 =를 이용해 만든 “할당 표현식” 우측에 생성되었습니다.

```
// 함수 표현식
let sum = function(a, b) {
  return a + b;
};
```

- 함수 선언문: 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재합니다.

```
// 함수 선언문
function sum(a, b) {
  return a + b;
}
```

> 함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성합니다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있습니다.
>
> 위 예시를 이용해 설명해 보도록 하겠습니다. 스크립트가 실행되고, 실행 흐름이 let sum = function…의 우측(함수 표현식)에 도달 했을때 함수가 생성됩니다. 이때 이후부터 해당 함수를 사용(할당, 호출 등)할 수 있습니다.
>
> 하지만 함수 선언문은 조금 다릅니다.
>
> 함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있습니다.
>
> 따라서 전역 함수 선언문은 스크립트 어디에 있느냐에 상관없이 어디에서든 사용할 수 있습니다.
>
> 이게 가능한 이유는 자바스크립트의 내부 알고리즘 때문입니다. 자바스크립트는 스크립트를 실행하기 전, 준비단계에서 전역에 선언된 함수 선언문을 찾고, 해당 함수를 생성합니다. 스크립트가 진짜 실행되기 전 "초기화 단계"에서 함수 선언 방식으로 정의한 함수가 생성되는 것이죠.

#

# 화살표 함수 기초

```
let func = (arg1, arg2, ...argN) => expression
```

이렇게 코드를 작성하면 인자 arg1..argN를 받는 함수 func이 만들어집니다. 함수 func는 화살표(=>) 우측의 표현식(expression)을 평가하고, 평가 결과를 반환합니다.

아래 함수의 축약 버전이라고 할 수 있죠.

```
let func = function(arg1, arg2, ...argN) {
  return expression;
};
```

## 본문이 여러 줄인 화살표 함수

그런데 평가해야 할 표현식이나 구문이 여러 개인 함수가 있을 수도 있습니다. 이 경우 역시 화살표 함수 문법을 사용해 함수를 만들 수 있습니다. 다만, 이때는 중괄호 안에 평가해야 할 코드를 넣어주어야 합니다. 그리고 `return` 지시자를 사용해 명시적으로 결괏값을 반환해 주어야 합니다.

```
let sum = (a, b) => {  // 중괄호는 본문 여러 줄로 구성되어 있음을 알려줍니다.
  let result = a + b;
  return result; // 중괄호를 사용했다면, return 지시자로 결괏값을 반환해주어야 합니다.
};

alert( sum(1, 2) ); // 3
```
